using System;
using System.Collections.Generic;
using System.Text;

public class CalculatorViewModel
{
    private static readonly Dictionary<string, int> precedence = new Dictionary<string, int>
    {
        { "+", 1 }, { "-", 1 },
        { "*", 2 }, { "/", 2 }
    };

    // 공백 없이 들어온 수식을 숫자, 연산자, 괄호 단위로 분리
    private List<string> Tokenize(string expression)
    {
        List<string> tokens = new List<string>();
        StringBuilder numberBuilder = new StringBuilder();  // StringBuilder는 내부에 가변 버퍼를 가지고 있다 . 문자열을 이어 붙이거나 수정할 때 새로운 문자열을 만들지 않고 내부 버퍼를 직접 수정한다. (반복적으											로 문자가 들어오는 이런 경우에 메모리가 효율적이다)

        foreach (char c in expression)
        {
            if (char.IsDigit(c) || c == '.') // 숫자 또는 소수점
            {
                numberBuilder.Append(c);
            }
            else  					// 수가 아닌 것이 들어왔을때,  
            {
                // 숫자 토큰 있으면 추가
                if (numberBuilder.Length > 0) //만약 숫자 토큰이 있었다면 tokens에 추가하고 numberBuilder를 클리어 해준다.
                {
                    tokens.Add(numberBuilder.ToString()); 
	            numberBuilder.Clear();  
                  }

                // 연산자 또는 괄호 추가
                if ("+-*/()".Contains(c))
                {
                    tokens.Add(c.ToString());
                }
                // 공백은 무시 가능
            }
        }

        // 마지막 숫자 토큰 추가
        if (numberBuilder.Length > 0) //만약 위에 연산이 끝났는데도 숫자가 남아있다면 토큰에 추가.
        {
            tokens.Add(numberBuilder.ToString());
        }

        return tokens;
    }

    // 중위 → 후위 변환
    public List<string> InfixToPostfix(string expression)
    {
        var tokens = Tokenize(expression);
        Stack<string> opStack = new Stack<string>();
        List<string> output = new List<string>();

        foreach (var token in tokens)
        {
            double num;
            if (double.TryParse(token, out num))
            {
                output.Add(token);
            }
            else if (token == "(")
            {
                opStack.Push(token);
            }
            else if (token == ")")
            {
                while (opStack.Count > 0 && opStack.Peek() != "(")
                    output.Add(opStack.Pop());
                if (opStack.Count > 0) opStack.Pop();
            }
            else
            {
                while (opStack.Count > 0 && opStack.Peek() != "(" &&
                       precedence[opStack.Peek()] >= precedence[token])
                    output.Add(opStack.Pop());
                opStack.Push(token);
            }
        }

        while (opStack.Count > 0)
            output.Add(opStack.Pop());

        return output;
    }

    // 후위식 계산
    public double EvaluatePostfix(List<string> postfixTokens)
    {
        Stack<double> stack = new Stack<double>();

        foreach (var token in postfixTokens)
        {
            double num;
            if (double.TryParse(token, out num))
            {
                stack.Push(num);
            }
            else
            {
                double b = stack.Pop();
                double a = stack.Pop();
                switch (token)
                {
                    case "+": stack.Push(a + b); break;
                    case "-": stack.Push(a - b); break;
                    case "*": stack.Push(a * b); break;
                    case "/":
                        if (b == 0) throw new DivideByZeroException("0으로 나눌 수 없습니다.");
                        stack.Push(a / b);
                        break;
                }
            }
        }

        return stack.Pop();
    }
}
